[{
  "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/File.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.length" : 105,
        "key.doc.type" : "Function",
        "key.parsed_scope.start" : 17,
        "key.kind" : "source.lang.swift.decl.function.free",
        "key.doc.full_as_xml" : "<Function file=\"\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/File.swift\" line=\"17\" column=\"13\"><Name>fileExists(filePath:)<\/Name><USR>s:24IDZSwiftScriptingGoodies10fileExistsSbSS0D4Path_tF<\/USR><Declaration>public func fileExists(filePath: String) -&gt; Bool<\/Declaration><CommentParts><Abstract><Para>Tests if a file or directory exists at a given path<\/Para><\/Abstract><Parameters><Parameter><Name>filePath<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>the file path<\/Para><\/Discussion><\/Parameter><\/Parameters><ResultDiscussion><Para>true if a file exist at <codeVoice>path<\/codeVoice><\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
        "key.nameoffset" : 330,
        "key.typename" : "(String) -> Bool",
        "key.doc.column" : 13,
        "key.doc.comment" : "Tests if a file or directory exists at a given path\n\n- parameter filePath: the file path\n- returns: true if a file exist at `path`",
        "key.bodyoffset" : 368,
        "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/File.swift",
        "key.doc.file" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/File.swift",
        "key.annotated_decl" : "<Declaration>public func fileExists(filePath: <Type usr=\"s:SS\">String<\/Type>) -&gt; <Type usr=\"s:Sb\">Bool<\/Type><\/Declaration>",
        "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>fileExists<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>filePath<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:Sb\">Bool<\/ref.struct><\/decl.function.returntype><\/decl.function.free>",
        "key.doc.declaration" : "public func fileExists(filePath: String) -> Bool",
        "key.substructure" : [

        ],
        "key.typeusr" : "_T0SbSS8filePath_tcD",
        "key.offset" : 325,
        "key.doc.line" : 17,
        "key.doc.name" : "fileExists(filePath:)",
        "key.name" : "fileExists(filePath:)",
        "key.usr" : "s:24IDZSwiftScriptingGoodies10fileExistsSbSS0D4Path_tF",
        "key.parsed_declaration" : "public func fileExists(filePath: String) -> Bool",
        "key.bodylength" : 61,
        "key.parsed_scope.end" : 19,
        "key.namelength" : 28
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.length" : 224,
        "key.doc.type" : "Function",
        "key.parsed_scope.start" : 28,
        "key.kind" : "source.lang.swift.decl.function.free",
        "key.doc.full_as_xml" : "<Function file=\"\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/File.swift\" line=\"28\" column=\"13\"><Name>mkdir(path:)<\/Name><USR>s:24IDZSwiftScriptingGoodies5mkdirSbSS4path_tF<\/USR><Declaration>public func mkdir(path: String) -&gt; Bool<\/Declaration><CommentParts><Abstract><Para>Creates a directory (and any needed intermediates) at a path.<\/Para><\/Abstract><Parameters><Parameter><Name>path<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>the path of the directory to be created<\/Para><\/Discussion><\/Parameter><\/Parameters><ResultDiscussion><Para>true if successful, false otherwise.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
        "key.nameoffset" : 633,
        "key.typename" : "(String) -> Bool",
        "key.doc.column" : 13,
        "key.doc.comment" : "Creates a directory (and any needed intermediates) at a path.\n\n- parameter path: the path of the directory to be created\n- returns: true if successful, false otherwise.",
        "key.bodyoffset" : 662,
        "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/File.swift",
        "key.doc.file" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/File.swift",
        "key.annotated_decl" : "<Declaration>public func mkdir(path: <Type usr=\"s:SS\">String<\/Type>) -&gt; <Type usr=\"s:Sb\">Bool<\/Type><\/Declaration>",
        "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>mkdir<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>path<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:Sb\">Bool<\/ref.struct><\/decl.function.returntype><\/decl.function.free>",
        "key.doc.declaration" : "public func mkdir(path: String) -> Bool",
        "key.substructure" : [

        ],
        "key.typeusr" : "_T0SbSS4path_tcD",
        "key.offset" : 628,
        "key.doc.line" : 28,
        "key.doc.name" : "mkdir(path:)",
        "key.name" : "mkdir(path:)",
        "key.usr" : "s:24IDZSwiftScriptingGoodies5mkdirSbSS4path_tF",
        "key.related_decls" : [
          {
            "key.annotated_decl" : "<RelatedName usr=\"c:@F@mkdir\">mkdir(_:_:)<\/RelatedName>"
          }
        ],
        "key.parsed_declaration" : "public func mkdir(path: String) -> Bool",
        "key.bodylength" : 189,
        "key.parsed_scope.end" : 36,
        "key.namelength" : 19
      }
    ],
    "key.offset" : 0,
    "key.length" : 853
  }
}, {
  "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.length" : 501,
        "key.doc.type" : "Function",
        "key.parsed_scope.start" : 17,
        "key.kind" : "source.lang.swift.decl.function.free",
        "key.doc.full_as_xml" : "<Function file=\"\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift\" line=\"17\" column=\"13\"><Name>path(path:relativeTo:)<\/Name><USR>s:24IDZSwiftScriptingGoodies4pathSSSgSSAB_SS10relativeTotF<\/USR><Declaration>public func path(path: String, relativeTo basePath: String) -&gt; String?<\/Declaration><CommentParts><Abstract><Para>Calculates the replative path from a base path to a traget path. -parameter path: the target path. -parameter relativeTo: the basePath<\/Para><\/Abstract><ResultDiscussion><Para>the relative path.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
        "key.nameoffset" : 359,
        "key.typename" : "(String, String) -> String?",
        "key.doc.column" : 13,
        "key.doc.comment" : "Calculates the replative path from a base path to a traget path.\n-parameter path: the target path.\n-parameter relativeTo: the basePath\n- returns: the relative path.",
        "key.bodyoffset" : 419,
        "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
        "key.doc.file" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
        "key.annotated_decl" : "<Declaration>public func path(path: <Type usr=\"s:SS\">String<\/Type>, relativeTo basePath: <Type usr=\"s:SS\">String<\/Type>) -&gt; <Type usr=\"s:SS\">String<\/Type>?<\/Declaration>",
        "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>path<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>path<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>relativeTo<\/decl.var.parameter.argument_label> <decl.var.parameter.name>basePath<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:SS\">String<\/ref.struct>?<\/decl.function.returntype><\/decl.function.free>",
        "key.doc.declaration" : "public func path(path: String, relativeTo basePath: String) -> String?",
        "key.substructure" : [

        ],
        "key.typeusr" : "_T0SSSgSS4path_SS10relativeTotcD",
        "key.offset" : 354,
        "key.doc.line" : 17,
        "key.doc.name" : "path(path:relativeTo:)",
        "key.name" : "path(path:relativeTo:)",
        "key.usr" : "s:24IDZSwiftScriptingGoodies4pathSSSgSSAB_SS10relativeTotF",
        "key.parsed_declaration" : "public func path(path: String, relativeTo basePath: String) -> String?",
        "key.bodylength" : 435,
        "key.parsed_scope.end" : 23,
        "key.namelength" : 47
      },
      {
        "key.modulename" : "Swift",
        "key.annotated_decl" : "<Declaration>struct String<\/Declaration>",
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>String<\/decl.name><\/decl.struct>",
        "key.doc.declaration" : "struct String",
        "key.length" : 513,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.length" : 97,
            "key.doc.type" : "Function",
            "key.parsed_scope.start" : 31,
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift\" line=\"31\" column=\"17\"><Name>trim()<\/Name><USR>s:SS24IDZSwiftScriptingGoodiesE4trimSSyF<\/USR><Declaration>public func trim() -&gt; String<\/Declaration><CommentParts><Abstract><Para>Trims trailing whitespace and newlines.<\/Para><\/Abstract><ResultDiscussion><Para>the trimmed string.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
            "key.nameoffset" : 1002,
            "key.typename" : "(String) -> () -> String",
            "key.doc.column" : 17,
            "key.doc.comment" : "Trims trailing whitespace and newlines.\n\n- returns: the trimmed string.",
            "key.bodyoffset" : 1020,
            "key.groupname" : "String",
            "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.doc.file" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.annotated_decl" : "<Declaration>public func trim() -&gt; <Type usr=\"s:SS\">String<\/Type><\/Declaration>",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>trim<\/decl.name>() -&gt; <decl.function.returntype><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.doc.declaration" : "public func trim() -> String",
            "key.substructure" : [

            ],
            "key.typeusr" : "_T0SSycD",
            "key.offset" : 997,
            "key.doc.line" : 31,
            "key.doc.name" : "trim()",
            "key.name" : "trim()",
            "key.usr" : "s:SS24IDZSwiftScriptingGoodiesE4trimSSyF",
            "key.parsed_declaration" : "public func trim() -> String",
            "key.bodylength" : 73,
            "key.parsed_scope.end" : 33,
            "key.namelength" : 6
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.length" : 99,
            "key.doc.type" : "Function",
            "key.parsed_scope.start" : 39,
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift\" line=\"39\" column=\"17\"><Name>split(c:)<\/Name><USR>s:SS24IDZSwiftScriptingGoodiesE5splitSaySSGs9CharacterV1c_tF<\/USR><Declaration>public func split(c: Character) -&gt; [String]<\/Declaration><CommentParts><Abstract><Para>Splits a string into components delimited by a spcific character<\/Para><\/Abstract><Parameters><Parameter><Name>c<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>the delimiter character.<\/Para><\/Discussion><\/Parameter><\/Parameters><ResultDiscussion><Para>the string components.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
            "key.nameoffset" : 1281,
            "key.typename" : "(String) -> (Character) -> [String]",
            "key.doc.column" : 17,
            "key.doc.comment" : "Splits a string into components delimited by a spcific character\n- parameter c: the delimiter character.\n- returns: the string components.",
            "key.bodyoffset" : 1314,
            "key.groupname" : "String",
            "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.doc.file" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.annotated_decl" : "<Declaration>public func split(c: <Type usr=\"s:s9CharacterV\">Character<\/Type>) -&gt; [<Type usr=\"s:SS\">String<\/Type>]<\/Declaration>",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>split<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>c<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.struct usr=\"s:s9CharacterV\">Character<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype>[<ref.struct usr=\"s:SS\">String<\/ref.struct>]<\/decl.function.returntype><\/decl.function.method.instance>",
            "key.doc.declaration" : "public func split(c: Character) -> [String]",
            "key.substructure" : [

            ],
            "key.typeusr" : "_T0SaySSGs9CharacterV1c_tcD",
            "key.offset" : 1276,
            "key.doc.line" : 39,
            "key.doc.name" : "split(c:)",
            "key.name" : "split(c:)",
            "key.usr" : "s:SS24IDZSwiftScriptingGoodiesE5splitSaySSGs9CharacterV1c_tF",
            "key.parsed_declaration" : "public func split(c: Character) -> [String]",
            "key.bodylength" : 60,
            "key.parsed_scope.end" : 41,
            "key.namelength" : 19
          }
        ],
        "key.is_system" : true,
        "key.doc.type" : "Class",
        "key.typeusr" : "_T0SSmD",
        "key.kind" : "source.lang.swift.decl.extension",
        "key.offset" : 864,
        "key.doc.full_as_xml" : "<Class><Name>String<\/Name><USR>s:SS<\/USR><Declaration>struct String<\/Declaration><CommentParts><Abstract><Para>A Unicode string value that is a collection of characters.<\/Para><\/Abstract><Discussion><Para>A string is a series of characters, such as <codeVoice>&quot;Swift&quot;<\/codeVoice>, that forms a collection. Strings in Swift are Unicode correct and locale insensitive, and are designed to be efficient. The <codeVoice>String<\/codeVoice> type bridges with the Objective-C class <codeVoice>NSString<\/codeVoice> and offers interoperability with C functions that works with strings.<\/Para><Para>You can create new strings using string literals or string interpolations. A <emphasis>string literal<\/emphasis> is a series of characters enclosed in quotes.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let greeting = \"Welcome!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para><emphasis>String interpolations<\/emphasis> are string literals that evaluate any included expressions and convert the results to string form. String interpolations give you an easy way to build a string from multiple pieces. Wrap each expression in a string interpolation in parentheses, prefixed by a backslash.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let name = \"Rosa\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let personalizedGreeting = \"Welcome, \\(name)!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ personalizedGreeting == \"Welcome, Rosa!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let price = 2]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let number = 3]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let cookiePrice = \"\\(number) cookies: $\\(price * number).\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ cookiePrice == \"3 cookies: $6.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Combine strings using the concatenation operator (<codeVoice>+<\/codeVoice>).<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let longerGreeting = greeting + \" We're glad you're here!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ longerGreeting == \"Welcome! We're glad you're here!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Multiline string literals are enclosed in three double quotation marks (<codeVoice>&quot;&quot;&quot;<\/codeVoice>), with each delimiter on its own line. Indentation is stripped from each line of a multiline string literal to match the indentation of the closing delimiter.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let banner = \"\"\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[          __,]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[         (          o   \/) _\/_]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[          `.  , , , ,  \/\/  \/]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        (___)(_(_\/_(_ \/\/_ (__]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[                     \/)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[                    (\/]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        \"\"\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Modifying and Comparing Strings<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Strings always have value semantics. Modifying a copy of a string leaves the original unaffected.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var otherGreeting = greeting]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[otherGreeting += \" Have a nice time!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ otherGreeting == \"Welcome! Have a nice time!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(greeting)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Welcome!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Comparing strings for equality using the equal-to operator (<codeVoice>==<\/codeVoice>) or a relational operator (like <codeVoice>&lt;<\/codeVoice> or <codeVoice>&gt;=<\/codeVoice>) is always performed using Unicode canonical representation. As a result, different representations of a string compare as being equal.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let cafe1 = \"Cafe\\u{301}\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let cafe2 = \"Café\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(cafe1 == cafe2)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"true\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The Unicode code point <codeVoice>&quot;\\u{301}&quot;<\/codeVoice> modifies the preceding character to include an accent, so <codeVoice>&quot;e\\u{301}&quot;<\/codeVoice> has the same canonical representation as the single Unicode code point <codeVoice>&quot;é&quot;<\/codeVoice>.<\/Para><Para>Basic string operations are not sensitive to locale settings, ensuring that string comparisons and other operations always have a single, stable result, allowing strings to be used as keys in <codeVoice>Dictionary<\/codeVoice> instances and for other purposes.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing String Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>A string is a collection of <emphasis>extended grapheme clusters<\/emphasis>, which approximate human-readable characters. Many individual characters, such as “é”, “김”, and “🇮🇳”, can be made up of multiple Unicode code points. These code points are combined by Unicode’s boundary algorithms into extended grapheme clusters, represented by the Swift <codeVoice>Character<\/codeVoice> type. Each element of a string is represented by a <codeVoice>Character<\/codeVoice> instance.<\/Para><Para>For example, to retrieve the first word of a longer string, you can search for a space and then create a substring from a prefix of the string up to that point:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let name = \"Marie Curie\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let firstSpace = name.index(of: \" \") ?? name.endIndex]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let firstName = name[..<firstSpace]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ firstName == \"Marie\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>firstName<\/codeVoice> constant is an instance of the <codeVoice>Substring<\/codeVoice> type—a type that represents substrings of a string while sharing the original string’s storage. Substrings present the same interface as strings.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(\"\\(name)'s first name has \\(firstName.count) letters.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Marie Curie's name has 5 letters.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing a String’s Unicode Representation<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>If you need to access the contents of a string as encoded in different Unicode encodings, use one of the string’s <codeVoice>unicodeScalars<\/codeVoice>, <codeVoice>utf16<\/codeVoice>, or <codeVoice>utf8<\/codeVoice> properties. Each property provides access to a view of the string as a series of code units, each encoded in a different Unicode encoding.<\/Para><Para>To demonstrate the different views available for every string, the following examples use this <codeVoice>String<\/codeVoice> instance:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let cafe = \"Cafe\\u{301} du 🌍\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(cafe)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Café du 🌍\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>cafe<\/codeVoice> string is a collection of the nine characters that are visible when the string is displayed.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(cafe.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"9\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(Array(cafe))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[\"C\", \"a\", \"f\", \"é\", \" \", \"d\", \"u\", \" \", \"🌍\"]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>Unicode Scalar View<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A string’s <codeVoice>unicodeScalars<\/codeVoice> property is a collection of Unicode scalar values, the 21-bit codes that are the basic unit of Unicode. Each scalar value is represented by a <codeVoice>Unicode.Scalar<\/codeVoice> instance and is equivalent to a UTF-32 code unit.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(cafe.unicodeScalars.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"10\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(Array(cafe.unicodeScalars))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[\"C\", \"a\", \"f\", \"e\", \"\\u{0301}\", \" \", \"d\", \"u\", \" \", \"\\u{0001F30D}\"]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(cafe.unicodeScalars.map { $0.value })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[67, 97, 102, 101, 769, 32, 100, 117, 32, 127757]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>unicodeScalars<\/codeVoice> view’s elements comprise each Unicode scalar value in the <codeVoice>cafe<\/codeVoice> string. In particular, because <codeVoice>cafe<\/codeVoice> was declared using the decomposed form of the <codeVoice>&quot;é&quot;<\/codeVoice> character, <codeVoice>unicodeScalars<\/codeVoice> contains the code points for both the letter <codeVoice>&quot;e&quot;<\/codeVoice> (101) and the accent character <codeVoice>&quot;´&quot;<\/codeVoice> (769).<\/Para><rawHTML><![CDATA[<h2>]]><\/rawHTML>UTF-16 View<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A string’s <codeVoice>utf16<\/codeVoice> property is a collection of UTF-16 code units, the 16-bit encoding form of the string’s Unicode scalar values. Each code unit is stored as a <codeVoice>UInt16<\/codeVoice> instance.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(cafe.utf16.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"11\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(Array(cafe.utf16))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[67, 97, 102, 101, 769, 32, 100, 117, 32, 55356, 57101]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The elements of the <codeVoice>utf16<\/codeVoice> view are the code units for the string when encoded in UTF-16. These elements match those accessed through indexed <codeVoice>NSString<\/codeVoice> APIs.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let nscafe = cafe as NSString]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(nscafe.length)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"11\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(nscafe.character(at: 3))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"101\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>UTF-8 View<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A string’s <codeVoice>utf8<\/codeVoice> property is a collection of UTF-8 code units, the 8-bit encoding form of the string’s Unicode scalar values. Each code unit is stored as a <codeVoice>UInt8<\/codeVoice> instance.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(cafe.utf8.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"14\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(Array(cafe.utf8))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[67, 97, 102, 101, 204, 129, 32, 100, 117, 32, 240, 159, 140, 141]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The elements of the <codeVoice>utf8<\/codeVoice> view are the code units for the string when encoded in UTF-8. This representation matches the one used when <codeVoice>String<\/codeVoice> instances are passed to C APIs.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let cLength = strlen(cafe)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(cLength)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"14\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Measuring the Length of a String<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>When you need to know the length of a string, you must first consider what you’ll use the length for. Are you measuring the number of characters that will be displayed on the screen, or are you measuring the amount of storage needed for the string in a particular encoding? A single string can have greatly differing lengths when measured by its different views.<\/Para><Para>For example, an ASCII character like the capital letter <emphasis>A<\/emphasis> is represented by a single element in each of its four views. The Unicode scalar value of <emphasis>A<\/emphasis> is <codeVoice>65<\/codeVoice>, which is small enough to fit in a single code unit in both UTF-16 and UTF-8.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let capitalA = \"A\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(capitalA.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(capitalA.unicodeScalars.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(capitalA.utf16.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(capitalA.utf8.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>On the other hand, an emoji flag character is constructed from a pair of Unicode scalar values, like <codeVoice>&quot;\\u{1F1F5}&quot;<\/codeVoice> and <codeVoice>&quot;\\u{1F1F7}&quot;<\/codeVoice>. Each of these scalar values, in turn, is too large to fit into a single UTF-16 or UTF-8 code unit. As a result, each view of the string <codeVoice>&quot;🇵🇷&quot;<\/codeVoice> reports a different length.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let flag = \"🇵🇷\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(flag.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(flag.unicodeScalars.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(flag.utf16.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"4\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(flag.utf8.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"8\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>To check whether a string is empty, use its <codeVoice>isEmpty<\/codeVoice> property instead of comparing the length of one of the views to <codeVoice>0<\/codeVoice>. Unlike with <codeVoice>isEmpty<\/codeVoice>, calculating a view’s <codeVoice>count<\/codeVoice> property requires iterating through the elements of the string.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing String View Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>To find individual elements of a string, use the appropriate view for your task. For example, to retrieve the first word of a longer string, you can search the string for a space and then create a new string from a prefix of the string up to that point.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let name = \"Marie Curie\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let firstSpace = name.index(of: \" \") ?? name.endIndex]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let firstName = name[..<firstSpace]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstName)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Marie\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Strings and their views share indices, so you can access the UTF-8 view of the <codeVoice>name<\/codeVoice> string using the same <codeVoice>firstSpace<\/codeVoice> index.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(Array(name.utf8[..<firstSpace]))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[77, 97, 114, 105, 101]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Note that an index into one view may not have an exact corresponding position in another view. For example, the <codeVoice>flag<\/codeVoice> string declared above comprises a single character, but is composed of eight code units when encoded as UTF-8. The following code creates constants for the first and second positions in the <codeVoice>flag.utf8<\/codeVoice> view. Accessing the <codeVoice>utf8<\/codeVoice> view with these indices yields the first and second code UTF-8 units.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstCodeUnit = flag.startIndex]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let secondCodeUnit = flag.utf8.index(after: firstCodeUnit)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ flag.utf8[firstCodeUnit] == 240]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ flag.utf8[secondCodeUnit] == 159]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>When used to access the elements of the <codeVoice>flag<\/codeVoice> string itself, however, the <codeVoice>secondCodeUnit<\/codeVoice> index does not correspond to the position of a specific character. Instead of only accessing the specific UTF-8 code unit, that index is treated as the position of the character at the index’s encoded offset. In the case of <codeVoice>secondCodeUnit<\/codeVoice>, that character is still the flag itself.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[\/\/ flag[firstCodeUnit] == \"🇵🇷\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ flag[secondCodeUnit] == \"🇵🇷\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>If you need to validate that an index from one string’s view corresponds with an exact position in another view, use the index’s <codeVoice>samePosition(in:)<\/codeVoice> method or the <codeVoice>init(_:within:)<\/codeVoice> initializer.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if let exactIndex = secondCodeUnit.samePosition(in: flag) {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(flag[exactIndex])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"No exact match for this position.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"No exact match for this position.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Performance Optimizations<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Although strings in Swift have value semantics, strings use a copy-on-write strategy to store their data in a buffer. This buffer can then be shared by different copies of a string. A string’s data is only copied lazily, upon mutation, when more than one string instance is using the same buffer. Therefore, the first in any sequence of mutating operations may cost O(<emphasis>n<\/emphasis>) time and space.<\/Para><Para>When a string’s contiguous storage fills up, a new buffer must be allocated and data must be moved to the new storage. String buffers use an exponential growth strategy that makes appending to a string a constant time operation when averaged over many append operations.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Bridging Between String and NSString<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Any <codeVoice>String<\/codeVoice> instance can be bridged to <codeVoice>NSString<\/codeVoice> using the type-cast operator (<codeVoice>as<\/codeVoice>), and any <codeVoice>String<\/codeVoice> instance that originates in Objective-C may use an <codeVoice>NSString<\/codeVoice> instance as its storage. Because any arbitrary subclass of <codeVoice>NSString<\/codeVoice> can become a <codeVoice>String<\/codeVoice> instance, there are no guarantees about representation or efficiency when a <codeVoice>String<\/codeVoice> instance is backed by <codeVoice>NSString<\/codeVoice> storage. Because <codeVoice>NSString<\/codeVoice> is immutable, it is just as though the storage was shared by a copy. The first in any sequence of mutating operations causes elements to be copied into unique, contiguous storage which may cost O(<emphasis>n<\/emphasis>) time and space, where <emphasis>n<\/emphasis> is the length of the string’s encoded representation (or more, if the underlying <codeVoice>NSString<\/codeVoice> has unusual performance characteristics).<\/Para><Para>For more information about the Unicode terms used in this discussion, see the <Link href=\"http:\/\/www.unicode.org\/glossary\/\">Unicode.org glossary<\/Link>. In particular, this discussion mentions <Link href=\"http:\/\/www.unicode.org\/glossary\/#extended_grapheme_cluster\">extended grapheme clusters<\/Link>, <Link href=\"http:\/\/www.unicode.org\/glossary\/#unicode_scalar_value\">Unicode scalar values<\/Link>, and <Link href=\"http:\/\/www.unicode.org\/glossary\/#canonical_equivalent\">canonical equivalence<\/Link>.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.nameoffset" : 874,
        "key.typename" : "String.Type",
        "key.doc.name" : "String",
        "key.name" : "String",
        "key.usr" : "s:SS",
        "key.bodyoffset" : 882,
        "key.bodylength" : 494,
        "key.namelength" : 6,
        "key.groupname" : "String"
      },
      {
        "key.modulename" : "Swift",
        "key.annotated_decl" : "<Declaration>struct String<\/Declaration>",
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>String<\/decl.name><\/decl.struct>",
        "key.doc.declaration" : "struct String",
        "key.length" : 655,
        "key.substructure" : [
          {
            "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.namelength" : 19,
            "key.annotated_decl" : "<Declaration>public func CSI(_ code: <Type usr=\"s:SS\">String<\/Type>) -&gt; <Type usr=\"s:SS\">String<\/Type><\/Declaration>",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>CSI<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>code<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.length" : 64,
            "key.substructure" : [

            ],
            "key.groupname" : "String",
            "key.parsed_scope.start" : 45,
            "key.typeusr" : "_T0S2ScD",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.offset" : 1416,
            "key.nameoffset" : 1421,
            "key.typename" : "(String) -> (String) -> String",
            "key.name" : "CSI(_:)",
            "key.usr" : "s:SS24IDZSwiftScriptingGoodiesE3CSIS2SF",
            "key.parsed_declaration" : "public func CSI(_ code: String) -> String",
            "key.bodyoffset" : 1452,
            "key.parsed_scope.end" : 45,
            "key.bodylength" : 27
          },
          {
            "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.namelength" : 5,
            "key.annotated_decl" : "<Declaration>public var black: <Type usr=\"s:SS\">String<\/Type> { get }<\/Declaration>",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>black<\/decl.name>: <decl.var.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.length" : 58,
            "key.groupname" : "String",
            "key.parsed_scope.start" : 46,
            "key.typeusr" : "_T0SSD",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.offset" : 1492,
            "key.nameoffset" : 1496,
            "key.typename" : "String",
            "key.name" : "black",
            "key.usr" : "s:SS24IDZSwiftScriptingGoodiesE5blackSSv",
            "key.parsed_declaration" : "public var black: String",
            "key.bodyoffset" : 1511,
            "key.parsed_scope.end" : 46,
            "key.bodylength" : 38
          },
          {
            "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.namelength" : 3,
            "key.annotated_decl" : "<Declaration>public var red: <Type usr=\"s:SS\">String<\/Type> { get }<\/Declaration>",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>red<\/decl.name>: <decl.var.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.length" : 56,
            "key.groupname" : "String",
            "key.parsed_scope.start" : 47,
            "key.typeusr" : "_T0SSD",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.offset" : 1562,
            "key.nameoffset" : 1566,
            "key.typename" : "String",
            "key.name" : "red",
            "key.usr" : "s:SS24IDZSwiftScriptingGoodiesE3redSSv",
            "key.parsed_declaration" : "public var red: String",
            "key.bodyoffset" : 1579,
            "key.parsed_scope.end" : 47,
            "key.bodylength" : 38
          },
          {
            "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.namelength" : 5,
            "key.annotated_decl" : "<Declaration>public var green: <Type usr=\"s:SS\">String<\/Type> { get }<\/Declaration>",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>green<\/decl.name>: <decl.var.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.length" : 58,
            "key.groupname" : "String",
            "key.parsed_scope.start" : 48,
            "key.typeusr" : "_T0SSD",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.offset" : 1630,
            "key.nameoffset" : 1634,
            "key.typename" : "String",
            "key.name" : "green",
            "key.usr" : "s:SS24IDZSwiftScriptingGoodiesE5greenSSv",
            "key.parsed_declaration" : "public var green: String",
            "key.bodyoffset" : 1649,
            "key.parsed_scope.end" : 48,
            "key.bodylength" : 38
          },
          {
            "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.namelength" : 6,
            "key.annotated_decl" : "<Declaration>public var yellow: <Type usr=\"s:SS\">String<\/Type> { get }<\/Declaration>",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>yellow<\/decl.name>: <decl.var.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.length" : 59,
            "key.groupname" : "String",
            "key.parsed_scope.start" : 49,
            "key.typeusr" : "_T0SSD",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.offset" : 1700,
            "key.nameoffset" : 1704,
            "key.typename" : "String",
            "key.name" : "yellow",
            "key.usr" : "s:SS24IDZSwiftScriptingGoodiesE6yellowSSv",
            "key.parsed_declaration" : "public var yellow: String",
            "key.bodyoffset" : 1720,
            "key.parsed_scope.end" : 49,
            "key.bodylength" : 38
          },
          {
            "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.namelength" : 4,
            "key.annotated_decl" : "<Declaration>public var blue: <Type usr=\"s:SS\">String<\/Type> { get }<\/Declaration>",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>blue<\/decl.name>: <decl.var.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.length" : 57,
            "key.groupname" : "String",
            "key.parsed_scope.start" : 50,
            "key.typeusr" : "_T0SSD",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.offset" : 1771,
            "key.nameoffset" : 1775,
            "key.typename" : "String",
            "key.name" : "blue",
            "key.usr" : "s:SS24IDZSwiftScriptingGoodiesE4blueSSv",
            "key.parsed_declaration" : "public var blue: String",
            "key.bodyoffset" : 1789,
            "key.parsed_scope.end" : 50,
            "key.bodylength" : 38
          },
          {
            "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.namelength" : 7,
            "key.annotated_decl" : "<Declaration>public var magenta: <Type usr=\"s:SS\">String<\/Type> { get }<\/Declaration>",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>magenta<\/decl.name>: <decl.var.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.length" : 60,
            "key.groupname" : "String",
            "key.parsed_scope.start" : 51,
            "key.typeusr" : "_T0SSD",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.offset" : 1840,
            "key.nameoffset" : 1844,
            "key.typename" : "String",
            "key.name" : "magenta",
            "key.usr" : "s:SS24IDZSwiftScriptingGoodiesE7magentaSSv",
            "key.parsed_declaration" : "public var magenta: String",
            "key.bodyoffset" : 1861,
            "key.parsed_scope.end" : 51,
            "key.bodylength" : 38
          },
          {
            "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.namelength" : 4,
            "key.annotated_decl" : "<Declaration>public var cyan: <Type usr=\"s:SS\">String<\/Type> { get }<\/Declaration>",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>cyan<\/decl.name>: <decl.var.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.length" : 57,
            "key.groupname" : "String",
            "key.parsed_scope.start" : 52,
            "key.typeusr" : "_T0SSD",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.offset" : 1912,
            "key.nameoffset" : 1916,
            "key.typename" : "String",
            "key.name" : "cyan",
            "key.usr" : "s:SS24IDZSwiftScriptingGoodiesE4cyanSSv",
            "key.parsed_declaration" : "public var cyan: String",
            "key.bodyoffset" : 1930,
            "key.parsed_scope.end" : 52,
            "key.bodylength" : 38
          },
          {
            "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/String.swift",
            "key.namelength" : 5,
            "key.annotated_decl" : "<Declaration>public var white: <Type usr=\"s:SS\">String<\/Type> { get }<\/Declaration>",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>white<\/decl.name>: <decl.var.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.length" : 58,
            "key.groupname" : "String",
            "key.parsed_scope.start" : 53,
            "key.typeusr" : "_T0SSD",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.offset" : 1981,
            "key.nameoffset" : 1985,
            "key.typename" : "String",
            "key.name" : "white",
            "key.usr" : "s:SS24IDZSwiftScriptingGoodiesE5whiteSSv",
            "key.parsed_declaration" : "public var white: String",
            "key.bodyoffset" : 2000,
            "key.parsed_scope.end" : 53,
            "key.bodylength" : 38
          }
        ],
        "key.is_system" : true,
        "key.doc.type" : "Class",
        "key.typeusr" : "_T0SSmD",
        "key.kind" : "source.lang.swift.decl.extension",
        "key.offset" : 1386,
        "key.doc.full_as_xml" : "<Class><Name>String<\/Name><USR>s:SS<\/USR><Declaration>struct String<\/Declaration><CommentParts><Abstract><Para>A Unicode string value that is a collection of characters.<\/Para><\/Abstract><Discussion><Para>A string is a series of characters, such as <codeVoice>&quot;Swift&quot;<\/codeVoice>, that forms a collection. Strings in Swift are Unicode correct and locale insensitive, and are designed to be efficient. The <codeVoice>String<\/codeVoice> type bridges with the Objective-C class <codeVoice>NSString<\/codeVoice> and offers interoperability with C functions that works with strings.<\/Para><Para>You can create new strings using string literals or string interpolations. A <emphasis>string literal<\/emphasis> is a series of characters enclosed in quotes.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let greeting = \"Welcome!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para><emphasis>String interpolations<\/emphasis> are string literals that evaluate any included expressions and convert the results to string form. String interpolations give you an easy way to build a string from multiple pieces. Wrap each expression in a string interpolation in parentheses, prefixed by a backslash.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let name = \"Rosa\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let personalizedGreeting = \"Welcome, \\(name)!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ personalizedGreeting == \"Welcome, Rosa!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let price = 2]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let number = 3]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let cookiePrice = \"\\(number) cookies: $\\(price * number).\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ cookiePrice == \"3 cookies: $6.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Combine strings using the concatenation operator (<codeVoice>+<\/codeVoice>).<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let longerGreeting = greeting + \" We're glad you're here!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ longerGreeting == \"Welcome! We're glad you're here!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Multiline string literals are enclosed in three double quotation marks (<codeVoice>&quot;&quot;&quot;<\/codeVoice>), with each delimiter on its own line. Indentation is stripped from each line of a multiline string literal to match the indentation of the closing delimiter.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let banner = \"\"\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[          __,]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[         (          o   \/) _\/_]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[          `.  , , , ,  \/\/  \/]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        (___)(_(_\/_(_ \/\/_ (__]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[                     \/)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[                    (\/]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        \"\"\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Modifying and Comparing Strings<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Strings always have value semantics. Modifying a copy of a string leaves the original unaffected.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var otherGreeting = greeting]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[otherGreeting += \" Have a nice time!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ otherGreeting == \"Welcome! Have a nice time!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(greeting)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Welcome!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Comparing strings for equality using the equal-to operator (<codeVoice>==<\/codeVoice>) or a relational operator (like <codeVoice>&lt;<\/codeVoice> or <codeVoice>&gt;=<\/codeVoice>) is always performed using Unicode canonical representation. As a result, different representations of a string compare as being equal.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let cafe1 = \"Cafe\\u{301}\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let cafe2 = \"Café\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(cafe1 == cafe2)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"true\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The Unicode code point <codeVoice>&quot;\\u{301}&quot;<\/codeVoice> modifies the preceding character to include an accent, so <codeVoice>&quot;e\\u{301}&quot;<\/codeVoice> has the same canonical representation as the single Unicode code point <codeVoice>&quot;é&quot;<\/codeVoice>.<\/Para><Para>Basic string operations are not sensitive to locale settings, ensuring that string comparisons and other operations always have a single, stable result, allowing strings to be used as keys in <codeVoice>Dictionary<\/codeVoice> instances and for other purposes.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing String Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>A string is a collection of <emphasis>extended grapheme clusters<\/emphasis>, which approximate human-readable characters. Many individual characters, such as “é”, “김”, and “🇮🇳”, can be made up of multiple Unicode code points. These code points are combined by Unicode’s boundary algorithms into extended grapheme clusters, represented by the Swift <codeVoice>Character<\/codeVoice> type. Each element of a string is represented by a <codeVoice>Character<\/codeVoice> instance.<\/Para><Para>For example, to retrieve the first word of a longer string, you can search for a space and then create a substring from a prefix of the string up to that point:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let name = \"Marie Curie\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let firstSpace = name.index(of: \" \") ?? name.endIndex]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let firstName = name[..<firstSpace]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ firstName == \"Marie\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>firstName<\/codeVoice> constant is an instance of the <codeVoice>Substring<\/codeVoice> type—a type that represents substrings of a string while sharing the original string’s storage. Substrings present the same interface as strings.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(\"\\(name)'s first name has \\(firstName.count) letters.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Marie Curie's name has 5 letters.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing a String’s Unicode Representation<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>If you need to access the contents of a string as encoded in different Unicode encodings, use one of the string’s <codeVoice>unicodeScalars<\/codeVoice>, <codeVoice>utf16<\/codeVoice>, or <codeVoice>utf8<\/codeVoice> properties. Each property provides access to a view of the string as a series of code units, each encoded in a different Unicode encoding.<\/Para><Para>To demonstrate the different views available for every string, the following examples use this <codeVoice>String<\/codeVoice> instance:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let cafe = \"Cafe\\u{301} du 🌍\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(cafe)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Café du 🌍\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>cafe<\/codeVoice> string is a collection of the nine characters that are visible when the string is displayed.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(cafe.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"9\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(Array(cafe))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[\"C\", \"a\", \"f\", \"é\", \" \", \"d\", \"u\", \" \", \"🌍\"]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>Unicode Scalar View<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A string’s <codeVoice>unicodeScalars<\/codeVoice> property is a collection of Unicode scalar values, the 21-bit codes that are the basic unit of Unicode. Each scalar value is represented by a <codeVoice>Unicode.Scalar<\/codeVoice> instance and is equivalent to a UTF-32 code unit.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(cafe.unicodeScalars.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"10\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(Array(cafe.unicodeScalars))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[\"C\", \"a\", \"f\", \"e\", \"\\u{0301}\", \" \", \"d\", \"u\", \" \", \"\\u{0001F30D}\"]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(cafe.unicodeScalars.map { $0.value })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[67, 97, 102, 101, 769, 32, 100, 117, 32, 127757]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>unicodeScalars<\/codeVoice> view’s elements comprise each Unicode scalar value in the <codeVoice>cafe<\/codeVoice> string. In particular, because <codeVoice>cafe<\/codeVoice> was declared using the decomposed form of the <codeVoice>&quot;é&quot;<\/codeVoice> character, <codeVoice>unicodeScalars<\/codeVoice> contains the code points for both the letter <codeVoice>&quot;e&quot;<\/codeVoice> (101) and the accent character <codeVoice>&quot;´&quot;<\/codeVoice> (769).<\/Para><rawHTML><![CDATA[<h2>]]><\/rawHTML>UTF-16 View<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A string’s <codeVoice>utf16<\/codeVoice> property is a collection of UTF-16 code units, the 16-bit encoding form of the string’s Unicode scalar values. Each code unit is stored as a <codeVoice>UInt16<\/codeVoice> instance.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(cafe.utf16.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"11\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(Array(cafe.utf16))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[67, 97, 102, 101, 769, 32, 100, 117, 32, 55356, 57101]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The elements of the <codeVoice>utf16<\/codeVoice> view are the code units for the string when encoded in UTF-16. These elements match those accessed through indexed <codeVoice>NSString<\/codeVoice> APIs.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let nscafe = cafe as NSString]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(nscafe.length)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"11\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(nscafe.character(at: 3))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"101\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>UTF-8 View<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A string’s <codeVoice>utf8<\/codeVoice> property is a collection of UTF-8 code units, the 8-bit encoding form of the string’s Unicode scalar values. Each code unit is stored as a <codeVoice>UInt8<\/codeVoice> instance.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(cafe.utf8.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"14\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(Array(cafe.utf8))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[67, 97, 102, 101, 204, 129, 32, 100, 117, 32, 240, 159, 140, 141]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The elements of the <codeVoice>utf8<\/codeVoice> view are the code units for the string when encoded in UTF-8. This representation matches the one used when <codeVoice>String<\/codeVoice> instances are passed to C APIs.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let cLength = strlen(cafe)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(cLength)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"14\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Measuring the Length of a String<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>When you need to know the length of a string, you must first consider what you’ll use the length for. Are you measuring the number of characters that will be displayed on the screen, or are you measuring the amount of storage needed for the string in a particular encoding? A single string can have greatly differing lengths when measured by its different views.<\/Para><Para>For example, an ASCII character like the capital letter <emphasis>A<\/emphasis> is represented by a single element in each of its four views. The Unicode scalar value of <emphasis>A<\/emphasis> is <codeVoice>65<\/codeVoice>, which is small enough to fit in a single code unit in both UTF-16 and UTF-8.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let capitalA = \"A\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(capitalA.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(capitalA.unicodeScalars.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(capitalA.utf16.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(capitalA.utf8.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>On the other hand, an emoji flag character is constructed from a pair of Unicode scalar values, like <codeVoice>&quot;\\u{1F1F5}&quot;<\/codeVoice> and <codeVoice>&quot;\\u{1F1F7}&quot;<\/codeVoice>. Each of these scalar values, in turn, is too large to fit into a single UTF-16 or UTF-8 code unit. As a result, each view of the string <codeVoice>&quot;🇵🇷&quot;<\/codeVoice> reports a different length.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let flag = \"🇵🇷\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(flag.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(flag.unicodeScalars.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(flag.utf16.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"4\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(flag.utf8.count)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"8\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>To check whether a string is empty, use its <codeVoice>isEmpty<\/codeVoice> property instead of comparing the length of one of the views to <codeVoice>0<\/codeVoice>. Unlike with <codeVoice>isEmpty<\/codeVoice>, calculating a view’s <codeVoice>count<\/codeVoice> property requires iterating through the elements of the string.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing String View Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>To find individual elements of a string, use the appropriate view for your task. For example, to retrieve the first word of a longer string, you can search the string for a space and then create a new string from a prefix of the string up to that point.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let name = \"Marie Curie\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let firstSpace = name.index(of: \" \") ?? name.endIndex]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let firstName = name[..<firstSpace]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstName)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Marie\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Strings and their views share indices, so you can access the UTF-8 view of the <codeVoice>name<\/codeVoice> string using the same <codeVoice>firstSpace<\/codeVoice> index.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(Array(name.utf8[..<firstSpace]))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[77, 97, 114, 105, 101]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Note that an index into one view may not have an exact corresponding position in another view. For example, the <codeVoice>flag<\/codeVoice> string declared above comprises a single character, but is composed of eight code units when encoded as UTF-8. The following code creates constants for the first and second positions in the <codeVoice>flag.utf8<\/codeVoice> view. Accessing the <codeVoice>utf8<\/codeVoice> view with these indices yields the first and second code UTF-8 units.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstCodeUnit = flag.startIndex]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let secondCodeUnit = flag.utf8.index(after: firstCodeUnit)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ flag.utf8[firstCodeUnit] == 240]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ flag.utf8[secondCodeUnit] == 159]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>When used to access the elements of the <codeVoice>flag<\/codeVoice> string itself, however, the <codeVoice>secondCodeUnit<\/codeVoice> index does not correspond to the position of a specific character. Instead of only accessing the specific UTF-8 code unit, that index is treated as the position of the character at the index’s encoded offset. In the case of <codeVoice>secondCodeUnit<\/codeVoice>, that character is still the flag itself.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[\/\/ flag[firstCodeUnit] == \"🇵🇷\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ flag[secondCodeUnit] == \"🇵🇷\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>If you need to validate that an index from one string’s view corresponds with an exact position in another view, use the index’s <codeVoice>samePosition(in:)<\/codeVoice> method or the <codeVoice>init(_:within:)<\/codeVoice> initializer.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if let exactIndex = secondCodeUnit.samePosition(in: flag) {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(flag[exactIndex])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"No exact match for this position.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"No exact match for this position.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Performance Optimizations<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Although strings in Swift have value semantics, strings use a copy-on-write strategy to store their data in a buffer. This buffer can then be shared by different copies of a string. A string’s data is only copied lazily, upon mutation, when more than one string instance is using the same buffer. Therefore, the first in any sequence of mutating operations may cost O(<emphasis>n<\/emphasis>) time and space.<\/Para><Para>When a string’s contiguous storage fills up, a new buffer must be allocated and data must be moved to the new storage. String buffers use an exponential growth strategy that makes appending to a string a constant time operation when averaged over many append operations.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Bridging Between String and NSString<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Any <codeVoice>String<\/codeVoice> instance can be bridged to <codeVoice>NSString<\/codeVoice> using the type-cast operator (<codeVoice>as<\/codeVoice>), and any <codeVoice>String<\/codeVoice> instance that originates in Objective-C may use an <codeVoice>NSString<\/codeVoice> instance as its storage. Because any arbitrary subclass of <codeVoice>NSString<\/codeVoice> can become a <codeVoice>String<\/codeVoice> instance, there are no guarantees about representation or efficiency when a <codeVoice>String<\/codeVoice> instance is backed by <codeVoice>NSString<\/codeVoice> storage. Because <codeVoice>NSString<\/codeVoice> is immutable, it is just as though the storage was shared by a copy. The first in any sequence of mutating operations causes elements to be copied into unique, contiguous storage which may cost O(<emphasis>n<\/emphasis>) time and space, where <emphasis>n<\/emphasis> is the length of the string’s encoded representation (or more, if the underlying <codeVoice>NSString<\/codeVoice> has unusual performance characteristics).<\/Para><Para>For more information about the Unicode terms used in this discussion, see the <Link href=\"http:\/\/www.unicode.org\/glossary\/\">Unicode.org glossary<\/Link>. In particular, this discussion mentions <Link href=\"http:\/\/www.unicode.org\/glossary\/#extended_grapheme_cluster\">extended grapheme clusters<\/Link>, <Link href=\"http:\/\/www.unicode.org\/glossary\/#unicode_scalar_value\">Unicode scalar values<\/Link>, and <Link href=\"http:\/\/www.unicode.org\/glossary\/#canonical_equivalent\">canonical equivalence<\/Link>.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.nameoffset" : 1396,
        "key.typename" : "String.Type",
        "key.doc.name" : "String",
        "key.name" : "String",
        "key.usr" : "s:SS",
        "key.bodyoffset" : 1404,
        "key.bodylength" : 636,
        "key.namelength" : 6,
        "key.groupname" : "String"
      }
    ],
    "key.offset" : 0,
    "key.length" : 2042
  }
}, {
  "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/Task.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.length" : 795,
        "key.doc.type" : "Function",
        "key.parsed_scope.start" : 18,
        "key.kind" : "source.lang.swift.decl.function.free",
        "key.doc.full_as_xml" : "<Function file=\"\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/Task.swift\" line=\"18\" column=\"13\"><Name>runShellCommand(command:)<\/Name><USR>s:24IDZSwiftScriptingGoodies15runShellCommandSi_SSSgACtSS7command_tF<\/USR><Declaration>public func runShellCommand(command: String) -&gt; (Int, String?, String?)<\/Declaration><CommentParts><Abstract><Para>Runs a shell command, capturing the exit status, standard output and standard error. This is synchronous function.<\/Para><\/Abstract><Parameters><Parameter><Name>command<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>the shell command, e.g. <codeVoice>\/bin\/ls -l<\/codeVoice><\/Para><\/Discussion><\/Parameter><\/Parameters><ResultDiscussion><Para>a tuple containing the exit status, standard output and standard error.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
        "key.nameoffset" : 460,
        "key.typename" : "(String) -> (Int, String?, String?)",
        "key.doc.column" : 13,
        "key.doc.comment" : "Runs a shell command, capturing the exit status, standard output and standard error.\nThis is synchronous function.\n\n- parameter command: the shell command, e.g. `\/bin\/ls -l`\n- returns: a tuple containing the exit status, standard output and standard error.",
        "key.bodyoffset" : 521,
        "key.filepath" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/Task.swift",
        "key.doc.file" : "\/Users\/danny\/Documents\/GitHub\/IDZSwiftScriptingGoodies\/Sources\/IDZSwiftScriptingGoodies\/Task.swift",
        "key.annotated_decl" : "<Declaration>public func runShellCommand(command: <Type usr=\"s:SS\">String<\/Type>) -&gt; (<Type usr=\"s:Si\">Int<\/Type>, <Type usr=\"s:SS\">String<\/Type>?, <Type usr=\"s:SS\">String<\/Type>?)<\/Declaration>",
        "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>runShellCommand<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>command<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><tuple>(<tuple.element><tuple.element.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/tuple.element.type><\/tuple.element>, <tuple.element><tuple.element.type><ref.struct usr=\"s:SS\">String<\/ref.struct>?<\/tuple.element.type><\/tuple.element>, <tuple.element><tuple.element.type><ref.struct usr=\"s:SS\">String<\/ref.struct>?<\/tuple.element.type><\/tuple.element>)<\/tuple><\/decl.function.returntype><\/decl.function.free>",
        "key.doc.declaration" : "public func runShellCommand(command: String) -> (Int, String?, String?)",
        "key.substructure" : [

        ],
        "key.typeusr" : "_T0Si_SSSgAAtSS7command_tcD",
        "key.offset" : 455,
        "key.doc.line" : 18,
        "key.doc.name" : "runShellCommand(command:)",
        "key.name" : "runShellCommand(command:)",
        "key.usr" : "s:24IDZSwiftScriptingGoodies15runShellCommandSi_SSSgACtSS7command_tF",
        "key.parsed_declaration" : "public func runShellCommand(command: String) -> (Int, String?, String?)",
        "key.bodylength" : 728,
        "key.parsed_scope.end" : 38,
        "key.namelength" : 32
      }
    ],
    "key.offset" : 0,
    "key.length" : 1251
  }
}]
